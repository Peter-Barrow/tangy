import cython
from _typeshed import Incomplete
from cython.cimports.cython import view as view
from cython.cimports.libc.stdio import fseek as fseek
from cython.cimports.libc.stdlib import free as free
from enum import Enum as Enum
from numpy import array as array, empty as empty, log2 as log2, ndarray as ndarray, ravel as ravel, reshape as reshape, uint as uint, uint32 as uint32, uint64
from typing import List, Optional, Tuple, Union

class RecordsStandard:
    count: uint64
    resolution: float
    channels: None
    timetags: None
    def asTime(self): ...
    def __len__(self) -> cython.Py_ssize_t: ...

class RecordsClocked:
    count: uint64
    resolution_coarse: float
    resolution_fine: float
    channels: None
    clocks: None
    deltas: None
    def asTime(self): ...
    def __len__(self) -> cython.Py_ssize_t: ...

Resolution: Incomplete
Record: Incomplete
TangyBuffer: Incomplete

class TagBuffer:
    def __init__(self, name: str, resolution: Union[float, Tuple[float, float]], length: int = 10000000, n_channels: int = 8) -> None: ...
    def __del__(self) -> None: ...
    @property
    def name(self): ...
    @property
    def file_descriptor(self): ...
    @property
    def capacity(self) -> int: ...
    @property
    def resolution(self) -> Union[float, Tuple[float, float]]: ...
    @resolution.setter
    def resolution(self, resolution: Union[float, Tuple[float, float]]): ...
    @property
    def count(self) -> int: ...
    @property
    def index_of_reference(self) -> int: ...
    @property
    def n_channels(self) -> int: ...
    def time_in_buffer(self) -> float: ...
    def bins_from_time(self, time: float) -> int: ...
    def lower_bound(self, time: float) -> int: ...

def singles(buffer: TagBuffer, read_time: Optional[float] = None, start: Optional[int] = None, stop: Optional[int] = None) -> Tuple[int, List[int]]: ...
def timetrace(buffer: TagBuffer, channels: List[int], read_time: float, resolution: float = 10): ...
def double_decay(time, tau1, tau2, t0, max_intensity): ...

class zero_delay_result:
    times: None
    intensities: None
    fit: None
    tau1: cython.double
    tau2: cython.double
    t0: cython.double
    max_intensity: cython.double

def find_zero_delay(buffer: TagBuffer, channel_a: int, channel_b: int, read_time: float, resolution: float = 1e-09) -> zero_delay_result: ...

class Coincidences:
    channels: None
    delays: None
    def __init__(self, buffer: TagBuffer, channels: List[int], delays: Optional[List[float]] = None) -> None: ...
    def __del__(self) -> None: ...
    def count(self, radius: float, read_time: float) -> int: ...
    def collect(self, radius: float, read_time: float): ...

class JointHistogram:
    data: None
    marginal_idler: None
    marginal_signal: None

class JointDelayHistogram:
    channels: None
    delays: None
    def __init__(self, buffer: TagBuffer, channels: List[int], signal: int, idler: int, radius: cython.double, clock: Optional[int] = 0, delays: Optional[List[float]] = None) -> None: ...
    def __del__(self) -> None: ...
    def histogram(self, bin_width: Optional[int] = 1, centre: bool = False) -> JointHistogram: ...
    def collect(self, read_time: float): ...

class PTUFile:
    def __init__(self, file_path: str, name: str, length: int = 1000) -> None: ...
    def __del__(self) -> None: ...
    def buffer(self): ...
    @property
    def record_count(self): ...
    @property
    def header(self): ...
    def __len__(self) -> int: ...
    @property
    def count(self): ...
    def read(self, n: uint64): ...
