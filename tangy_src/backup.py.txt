
@cython.cclass
class TangyArray:

    _type: tangy.BufferType
    _buffer: _Buffer
    _ptr: _Buffer_Ptr
    _data: TagData

    def __init__(self,
                 data: TagData,
                 resolution: Union[float, Tuple[float, float]],
                 n_channels: int):

        if type(data) is StandardData:
            self._type = _tangy.BufferType.Standard
            if type(resolution) is not float:
                raise TypeError
            self._buffer.standard = _tangy.std_buffer_new()[0]
            self._ptr = _Buffer_Ptr(standard=cython.address(self._buffer.standard))

            self._data = data
            channel_view: u8[:] = self._data[0]
            timestamp_view: u64[:] = self.data[1]

            self._buffer.standard.ptrs.channel = cython.address(channel_view[0])
            self._buffer.standard.ptrs.timestamp = cython.address(timestamp_view[0])

        else:
            self._type = _tangy.BufferType.Clocked
            if type(resolution) is not Tuple[float, float]:
                raise TypeError
            self._buffer.clocked = _tangy.clk_buffer_new()[0]
            self._ptr = _Buffer_Ptr(clocked=cython.address(self._buffer.clocked))
            _resolution: _tangy.clk_res
            _resolution.coarse = resolution[0]
            _resolution.fine = resolution[1]


@cython.cclass
class TangyBuffer:
    """Interface to underlying ring buffer

    Args:
        name (str): Name of buffer to be created or attached to.
        resolution (Union[float, Tuple[float, float]]): Resolution \
        of timetags in seconds. A single float for the "standard timetags". A \
        pair of floats for "clocked timetags" with a "coarse" and "fine" \
        timing structure. Unused if connecting. In seconds.
        n_channels (Optional[int]): Number of channels
        length (Optional[int] = 10_000_000): Length of buffer to create. \
        Unused if connecting.

    Attributes:
        name (str): Name of buffer
        file_descriptor (int): File descriptor of underlying ring buffer
        capacity (int): Size of buffer
        resolution (Union[float, Tuple[float, float]]): Single float for \
        a buffer of ``standard timetags`` or a pair of floats for buffers of \
        ``clocked timetags`` (coarse resolution, fine resolution). Resolutions \
        are in seconds.
        count (int): Number of elements that have been written to the buffer
        index_of_reference (int): On/off marker
        n_channels (int): Number of channels the buffer can contain

    Note:
        If connecting to an existing buffer the resolution, n_channels and \
        length arguments will be ignored even if supplied.

    Note:
        For buffers using the clocked timetag format the resolution must be \
        specified as a tuple in the form (coarse resolution, fine resolution).\
        As an example a clock signal from an 80Mhz TiSapphire laser and a fine\
        resolution on-board the time timetagger would give: \
        ``resolution = (12.5e-9, 1e-12)``

    Examples:
        Creation of a TangyBuffer object for both the ``Standard`` and \
        ``Clocked`` timetag formats that can hold 1,000,000 timetags for a \
        device with 4 channels. The method to connect to these buffers is also \
        shown. This method of creating new buffers and connecting to existing \
        ones allows the user to hold on to and continously read timetags from \
        a device in one process and then connect to that buffer in another to \
        perform analysis on the current data.
        === "Buffer in ``Standard`` format"
            ```python
            # Here we will create a buffer called 'standard' (imaginitive)
            # that will only except timetags in the ``Standard`` format, this is
            # selected by only supplying a single value for the resolution
            standard_buffer = tangy.TangyBuffer("standard", 1e-9, 4, int(1e6))

            # A new buffer object can be made by connecting to a buffer with
            # the correct name
            standard_buffer_connection = tangy.TangyBuffer("standard")
            ```

        === "Buffer in ``Clocked`` format"
            ```python
            # Here we will create a buffer called 'clocked' (imaginitive)
            # that will only except timetags in the ``Clocked`` format, this is
            # selected by supplying a pair of values for the resolution
            resolution = (12.5e-9, 1e-12) # 80Mhz Clock and 1ps fine resolution
            clocked_buffer = tangy.TangyBuffer("clocked", resolution, 4, int(1e6))

            # A new buffer object can be made by connecting to a buffer with
            # the correct name
            clocked_buffer_connection = tangy.TangyBuffer("clocked")
            ```
    """

    _type: _tangy.BufferType
    _buffer: _Buffer
    _ptr: _Buffer_Ptr
    # _v_ptr: cython.void_p
    _v_ptr = cython.declare(cython.pointer(cython.void))
    _name = cython.declare(bytes)

    def __init__(self, name: str,
                 resolution: Optional(Union[float, Tuple[float, float]]) = 1e-12,
                 length: int = 10_000_000,
                 n_channels: int = 8):

        self._name = name.encode('utf-8')
        c_name: cython.p_char = self._name

        # First check if there is a buffer with the expected name and connect to it
        # If there are two buffers with the same top level pick the one prefixed
        # as a standard buffer i.e. clk_*name*

        result: _tangy.tbResult
        result = _tangy.std_buffer_connect(c_name, cython.address(self._buffer.standard))
        if result.Ok is True:
            self._type = _tangy.BufferType.Standard
            self._ptr = _Buffer_Ptr(standard=cython.address(self._buffer.standard))
            self._v_ptr = cython.cast(cython.pointer(cython.void), self._ptr.standard)
            return

        # If that failed now check for a clocked buffer
        result = _tangy.clk_buffer_connect(c_name, cython.address(self._buffer.clocked))
        if result.Ok is True:
            self._type = _tangy.BufferType.Clocked
            self._ptr = _Buffer_Ptr(clocked=cython.address(self._buffer.clocked))
            self._v_ptr = cython.cast(cython.pointer(cython.void), self._ptr.clocked)
            return

        # No buffer has been found so make one
        if type(resolution) is float:
            self._type = _tangy.BufferType.Standard
            result = _tangy.std_buffer_init(length, resolution, n_channels, c_name,
                                            cython.address(self._buffer.standard))
            if False is result.Ok:
                # raise an error
                raise MemoryError

            _tangy.std_buffer_info_init(self._buffer.standard.map_ptr,
                                        cython.address(self._buffer.standard))
            self._ptr = _Buffer_Ptr(
                standard=cython.address(self._buffer.standard))
            self._v_ptr = cython.cast(cython.pointer(cython.void), self._ptr.standard)
            return

        elif type(resolution) is tuple:
            self._type = _tangy.BufferType.Clocked
            _resolution: _tangy.clk_res
            _resolution.coarse = resolution[0]
            _resolution.fine = resolution[1]

            result = _tangy.clk_buffer_init(length, _resolution, n_channels, c_name,
                                            cython.address(self._buffer.clocked))
            if False is result.Ok:
                # raise an error
                raise MemoryError

            _tangy.clk_buffer_info_init(self._buffer.clocked.map_ptr,
                                        cython.address(self._buffer.clocked))
            self._ptr = _Buffer_Ptr(
                clocked=cython.address(self._buffer.clocked))
            self._v_ptr = cython.cast(cython.pointer(cython.void), self._ptr.clocked)
            return

        # This should never get this far, if it does then the arguments aren't valid
        raise ValueError

    def __del__(self):
        result: _tangy.tbResult
        if self._type is _tangy.BufferType.Standard:
            result = _tangy.std_buffer_deinit(self._ptr.standard)
        elif self._type is _tangy.BufferType.Clocked:
            result = _tangy.clk_buffer_deinit(self._ptr.clocked)
        # TODO: check result...

    def __len__(self):
        return self.capacity

    def __call__(self, time: float) -> int:
        return self._call(time)

    @cython.cfunc
    def _call(self, time: float) -> int:

        time_at_start: f64n = 0
        time_at_stop: f64n = 0
        (time_at_start, time_at_stop) = self.time_range()

        idx: int = self.begin

        if time < 0:
            return self.lower_bound(time_at_stop + time)

        if time <= time_at_stop:
            return self.lower_bound(time_at_start + time)

        # NOTE: should look into upper_bound here for searching from start...

        return 0

    @property
    def end(self) -> int:
        """doc"""
        return self.count - 1

    @property
    def begin(self) -> int:
        """doc"""
        return self.oldest_index()

    @cython.boundscheck(False)
    @cython.wraparound(False)
    def __getitem__(self, key):
        return self._get(key)

    @cython.ccall
    def oldest_index(self) -> int:
        if self._type is _tangy.BufferType.Standard:
            return _tangy.std_oldest_index(self._ptr.standard)
        if self._type is _tangy.BufferType.Clocked:
            return _tangy.clk_oldest_index(self._ptr.clocked)

    @cython.ccall
    def _make_slice(self, key):
        start: int
        stop: int
        step: int = 1

        if type(key) is slice:
            oldest = self.begin

            dist: int = abs(abs(key.stop) - abs(key.start))
            if (key.start > self.capacity) or (key.stop > self.capacity):
                if dist > self.capacity:
                    raise IndexError("out of range")
                start = key.start
                stop = key.stop
                return (start, stop, step)

            # if key.start < self.begin:
            #     start = oldest + self.begin
            if key.start < 0:
                start = (self.count + key.start - 1) % self.capacity
                stop = start + dist + 1
            else:
                start = key.start
                if start < self.begin:
                    start += self.begin
                start = (start % self.capacity)
                # stop = start + dist + 1
                stop = key.stop
                if stop < self.begin:
                    stop += self.begin
                stop = (stop % self.capacity) + 1

            # start = (key.start % self.capacity)
            # # stop = start + key.stop
            # stop = start + dist + 1

        if type(key) is int:
            if abs(key) > self.count:
                raise IndexError("out of range")

            if (key > self.capacity):
                start = key
                stop = key + 1
                return (start, stop, step)

            if key < 0:
                start = (self.count + key - 1) % self.capacity
                stop = start + 1
            else:
                if key < self.begin:
                    key += self.begin
                start = (key % self.capacity)
                stop = start + 1

        if abs(abs(stop) - abs(start)) > self.count:
            raise IndexError("out of range")

        return (start, stop, step)

    @cython.ccall
    def _get(self, key):
        start: int
        stop: int
        step: int

        (start, stop, step) = self._make_slice(key)
        n: u64n = abs(stop - start)

        count: u64n
        channels: u8n[:] = zeros(n, dtype=u8n)
        channels_view: cython.uchar[:] = channels

        if self._type is _tangy.BufferType.Standard:
            ptrs_std: _tangy.std_slice
            ptrs_std.length = n
            ptrs_std.channel = cython.address(channels_view[0])

            timestamps: u64n[:] = zeros(n, dtype=u64n)
            timestamps_view: u64[:] = timestamps
            ptrs_std.timestamp = cython.address(timestamps_view[0])

            count = _tangy.std_buffer_slice(self._ptr.standard,
                                            cython.address(ptrs_std),
                                            start, stop)

            return (channels[::step], timestamps[::step])

        elif self._type is _tangy.BufferType.Clocked:
            ptrs_clk: _tangy.clk_field_ptrs
            ptrs_clk.length = n
            ptrs_clk.channels = cython.address(channels_view[0])

            clocks: u64n[:] = zeros(n, dtype=u64n)
            clocks_view: u64[:] = clocks
            ptrs_clk.clocks = cython.address(clocks_view[0])

            deltas: u64n[:] = zeros(n, dtype=u64n)
            deltas_view: u64[:] = deltas
            ptrs_clk.deltas = cython.address(deltas_view[0])

            count = _tangy.clk_buffer_slice(self._ptr.clocked,
                                            cython.address(ptrs_clk),
                                            start, stop)
            return (channels[::step], clocks[::step], deltas[::step])

    @cython.ccall
    def push(self, channels: ndarray(u8n),
             timetags: Union[ndarray(u64n),
                             Tuple(ndarray(u64n), ndarray(u64n))]):

        count: u64n = 0
        n_channels: int = len(channels)

        start: u64n = self.count
        stop: u64n = start + n_channels

        if type(timetags) is ndarray(u64n):
            n_timetags: int = len(timetags)
            if n_channels != n_timetags:
                ValueError
            channels_view: cython.uchar[:] = channels
            timetags_view: u64[:] = timetags
            ptrs_std: _tangy.std_slice
            ptrs_std.length = n_channels
            ptrs_std.channel = cython.address(channels_view[0])
            ptrs_std.timestamp = cython.address(timetags_view[0])
            count = _tangy.std_buffer_push(self._ptr.standard,
                                           ptrs_std, start, stop)

        elif type(timetags) is Tuple[ndarray(u64n), ndarray(u64n)]:
            (clocks, deltas) = timetags
            n_clocks: int = len(clocks)
            n_deltas: int = len(deltas)
            if (n_channels != n_clocks) or (n_channels != n_deltas):
                ValueError
            channels_view: cython.uchar[:] = channels
            clocks_view: u64[:] = clocks
            deltas_view: u64[:] = deltas
            ptrs_clk: _tangy.clk_field_ptrs
            ptrs_clk.length = n_channels
            ptrs_clk.channels = cython.address(channels_view[0])
            ptrs_clk.clocks = cython.address(clocks_view[0])
            ptrs_clk.deltas = cython.address(deltas_view[0])
            count = _tangy.clk_buffer_push(self._ptr.clocked,
                                           ptrs_clk, start, stop)
        return

    @property
    def name(self):
        if self._type is _tangy.BufferType.Standard:
            return self._buffer.standard.name
        elif self._type is _tangy.BufferType.Clocked:
            return self._buffer.clocked.name

    @property
    def file_descriptor(self):
        if self._type is _tangy.BufferType.Standard:
            return self._buffer.standard.file_descriptor
        elif self._type is _tangy.BufferType.Clocked:
            return self._buffer.clocked.file_descriptor

    @property
    def capacity(self) -> int:
        if self._type is _tangy.BufferType.Standard:
            return self._buffer.standard.capacity[0]
        elif self._type is _tangy.BufferType.Clocked:
            return self._buffer.clocked.capacity[0]

    @property
    def resolution(self) -> Union[float, Tuple[float, float]]:
        if self._type is _tangy.BufferType.Standard:
            return self._buffer.standard.resolution[0]
        elif self._type is _tangy.BufferType.Clocked:
            return (self._buffer.clocked.resolution[0].coarse,
                    self._buffer.clocked.resolution[0].fine)

    @resolution.setter
    def resolution(self, resolution: Union[float, Tuple[float, float]]):
        if self._type is _tangy.BufferType.Standard and \
                type(resolution) is float:
            self._buffer.standard.resolution[0] = resolution
        elif self._type is _tangy.BufferType.Clocked and \
                type(resolution) is tuple:
            _res: _tangy.clk_res
            _res.coarse = resolution[0]
            _res.fine = resolution[1]
            self._buffer.clocked.resolution[0] = _res

    @property
    def count(self) -> int:
        if self._type is _tangy.BufferType.Standard:
            return self._buffer.standard.count[0]
        elif self._type is _tangy.BufferType.Clocked:
            return self._buffer.clocked.count[0]

    @property
    def index_of_reference(self) -> int:
        if self._type is _tangy.BufferType.Standard:
            return self._buffer.standard.index_of_reference[0]
        elif self._type is _tangy.BufferType.Clocked:
            return self._buffer.clocked.index_of_reference[0]

    @property
    def n_channels(self) -> int:
        if self._type is _tangy.BufferType.Standard:
            return self._buffer.standard.n_channels[0]
        elif self._type is _tangy.BufferType.Clocked:
            return self._buffer.clocked.n_channels[0]

    @cython.ccall
    def time_in_buffer(self) -> float:
        """ Amount of time held in the buffer
        Returns:
            (float): Time between oldest and newest timetags
        """
        if self._type is _tangy.BufferType.Standard:
            return _tangy.std_time_in_buffer(self._ptr.standard)
        elif self._type is _tangy.BufferType.Clocked:
            return _tangy.clk_time_in_buffer(self._ptr.clocked)

    @cython.ccall
    def time_range(self) -> Tuple[float, float]:
        # begin: float = time_at_index(self._v_ptr, self._type, self.begin % self.capacity)
        # end: float = time_at_index(self._v_ptr, self._type, self.end % self.capacity)
        begin: float
        end: float
        idx: int
        if self._type is _tangy.BufferType.Standard:
            idx = (self.begin + 1) % self.capacity
            s_rec: _tangy.standard = _tangy.std_record_at(self._ptr.standard, idx)
            begin = _tangy.std_to_time(s_rec, self._buffer.standard.resolution[0])

            idx = self.end % self.capacity
            s_rec = _tangy.std_record_at(self._ptr.standard, idx)
            end = _tangy.std_to_time(s_rec, self._buffer.standard.resolution[0])

        elif self._type is _tangy.BufferType.Clocked:
            idx = (self.begin + 1) % self.capacity
            c_rec: _tangy.clocked = _tangy.clk_record_at(self._ptr.clocked, idx)
            begin = _tangy.clk_to_time(c_rec, self._buffer.clocked.resolution[0])

            idx = self.end % self.capacity
            c_rec = _tangy.clk_record_at(self._ptr.clocked, idx)
            end = _tangy.clk_to_time(c_rec, self._buffer.clocked.resolution[0])

        return (begin, end)

    @cython.ccall
    def bins_from_time(self, time: float) -> int:
        """ Convert amount of time to a number of time bins

        Args:
            time (float): Amount of time in seconds

        Returns:
            (int): number of bins

        Note:
            For buffers with the clocked timetag format this will be in units\
            of the fine resolution.

        """
        bins: u64n = 0
        if self._type is _tangy.BufferType.Standard:
            bins = _tangy.std_bins_from_time(
                self._buffer.standard.resolution[0], time)
        elif self._type is _tangy.BufferType.Clocked:
            bins = _tangy.clk_bins_from_time(
                self._buffer.clocked.resolution[0], time)
        return bins

    @cython.ccall
    def lower_bound(self, time: float) -> int:
        """ Find the position in the buffer that gives the last "time" seconds\
        in the buffer

        Performs a binary search on the buffer where the location being \
        searched for is ``buffer.time_in_buffer() - time``.

        Args:
            time (float): Amount of time, in seconds, to split the buffer by

        Returns:
            (int): Index in buffer corresponding to the timetag that is greater\
            than or equal to ``buffer.time_in_buffer() - time``

        """

        bins: u64n = self.bins_from_time(time)
        index: u64n = 0

        if self._type is _tangy.BufferType.Standard:
            index = _tangy.std_lower_bound(self._ptr.standard, bins)
        elif self._type is _tangy.BufferType.Clocked:
            index = _tangy.clk_lower_bound(self._ptr.clocked, bins)

        return index


def singles(buffer: TangyBuffer, read_time: Optional[float] = None,
            start: Optional[int] = None, stop: Optional[int] = None
            ) -> Tuple[int, List[int]]:
    """Count the occurances of each channel over a region of the buffer

    Args:
        buffer (RecordBuffer): Buffer containing timetags
        read_time (Optional[float] = None): Length of time to integrate over
        start (Optional[int] = None): Buffer position to start counting from
        stop (Optional[int] = None): Buffer position to sotp counting to

    Returns:
        (int, List[int]): Total counts and list of total counts on each channel

    Examples:
        Get all of the singles in a buffer
        >>> tangy.singles(buffer, buffer.time_in_buffer())

        Count the singles in the last 1s
        >>> tangy.singles(buffer, 1)

        Count the singles in the last 1000 tags
        >>> tangy.singles(buffer, buffer.count - 1000, buffer.count)
    """

    counters: u64n[:] = zeros(buffer.n_channels, dtype=u64n)
    counters_view: u64[::1] = counters

    if read_time:
        read_time: f64n = read_time
        start: u64n = buffer.lower_bound(read_time)

    if stop is None:
        stop: u64n = buffer.count - 1

    total: u64n = 0

    if buffer._type is _tangy.BufferType.Standard:
        total = _tangy.std_singles(buffer._ptr.standard, start, stop,
                                   cython.address(counters_view[0]))

    elif buffer._type is _tangy.BufferType.Standard:
        total = _tangy.clk_singles(buffer._ptr.clocked, start, stop,
                                   cython.address(counters_view[0]))

    return (total, counters)


@cython.ccall
def timetrace(buffer: TangyBuffer, channels: List[int], read_time: float,
              resolution: float = 10):

    n_channels: u64n = len(channels)
    # channels: u8n[:] = asarray(channels, dtype=u8n)
    channels_view: cython.uchar[::1] = asarray(channels, dtype=u8n)
    channels_ptr: cython.pointer(cython.uchar) = cython.address(
        channels_view[0])

    buffer_resolution: f64n = 0
    if buffer._type is _tangy.BufferType.Standard:
        buffer_resolution = buffer.resolution
    elif buffer._type is _tangy.BufferType.Clocked:
        buffer_resolution = buffer.resolution[1]    # fine resolution

    bin_width: u64n = round(resolution / buffer_resolution)

    n: cython.int = 1
    if resolution < read_time:
        n = int(read_time // resolution) + 1

    intensity_vec: cython.pointer(_tangy.vec_u64) = _tangy.vector_u64_init(n)

    intensities: u64n[:] = zeros(n, dtype=u64n)
    # intensities = zeros(n, dtype=u64n)
    intensities_view: u64[::1] = intensities
    if buffer._type is _tangy.BufferType.Standard:
        total: u64n = _tangy.std_timetrace(buffer._ptr.standard,
                                           read_time,
                                           bin_width,
                                           channels_ptr,
                                           n_channels,
                                           n,
                                           intensity_vec)
    elif buffer._type is _tangy.BufferType.Clocked:
        total: u64n = _tangy.clk_timetrace(buffer._ptr.clocked,
                                           read_time,
                                           bin_width,
                                           channels_ptr,
                                           n_channels,
                                           n,
                                           intensity_vec)

    intensities: u64n[:] = zeros(intensity_vec.length, dtype=u64n)
    intensities_view: u64[::1] = intensities
    for i in range(intensity_vec.length):
        intensities_view[i] = intensity_vec.data[i]

    intensity_vec = _tangy.vector_u64_deinit(intensity_vec)

    return intensities

@cython.ccall
def find_zero_delay(buffer: TangyBuffer, channel_a: int, channel_b: int,
                    read_time: float, resolution: float = 1e-9,
                    window: Optional[float] = None
                    ) -> zero_delay_result:

    trace_res: f64n = 5e-2
    trace: u64n[:] = timetrace(
        buffer, [channel_a, channel_b], read_time, trace_res)

    avrg_intensity = mean(trace) / trace_res

    if window is None:
        correlation_window = 2 / avrg_intensity * 2

    correlation_window = f64n(window)

    if resolution is None:
        resolution = (2 / avrg_intensity) / 8000

    res: f64n = 0
    if buffer._type is _tangy.BufferType.Standard:
        res = buffer._buffer.standard.resolution[0]
    elif buffer._type is _tangy.BufferType.Clocked:
        res = buffer._buffer.clocked.resolution[0].fine

    n_bins: u64n = round(correlation_window / resolution) - 1
    correlation_window = correlation_window / res

    measurement_resolution: u64n = u64n(
        correlation_window / f64n(n_bins))

    correlation_window = n_bins * measurement_resolution
    n_bins = n_bins * 2
    intensities: u64n[:] = zeros(int(n_bins), dtype=u64n)
    intensities_view: u64[::1] = intensities

    if buffer._type is _tangy.BufferType.Standard:
        _tangy.std_find_zero_delay(buffer._ptr.standard,
                                   read_time,
                                   u64n(correlation_window),
                                   measurement_resolution,
                                   channel_a,
                                   channel_b,
                                   n_bins,
                                   cython.address(intensities_view[0]))

    elif buffer._type is _tangy.BufferType.Clocked:
        _tangy.clk_find_zero_delay(buffer._ptr.clocked,
                                   read_time,
                                   u64n(correlation_window),
                                   measurement_resolution,
                                   channel_a,
                                   channel_b,
                                   n_bins,
                                   cython.address(intensities_view[0]))

    times = (arange(n_bins) - (n_bins // 2)) * resolution
    max_idx = intensities.argmax()
    # intensities[max_idx] = 0
    # intensities[n_bins // 2] = intensities[(n_bins // 2) - 1]
    t0 = times[intensities.argmax()]

    tau = 2 / avrg_intensity
    max_intensity = intensities.max()

    guess = [tau, tau, t0, max_intensity]

    [opt, cov] = curve_fit(double_decay, times, intensities, p0=guess)
    hist_fit = double_decay(times, *opt)

    central_delay = t0

    if buffer._type is _tangy.BufferType.Clocked:
        index = buffer.lower_bound(buffer.time_in_buffer() - 1)
        channels, clocks, deltas = buffer[index:buffer.count - 1]
        temporal_window = int(buffer.resolution[0] / buffer.resolution[1])
        bins = arange(temporal_window)
        hist_a, edges = nphist(deltas[channels == channel_a], bins)
        central_delay += mean(bins[:-1][hist_a > (0.5 * max(hist_a))]) * (1e-12)

    result = zero_delay_result(
        times=times,
        intensities=intensities,
        fit=hist_fit,
        tau1=opt[0],
        tau2=opt[1],
        t0=opt[2],
        central_delay=central_delay,
        max_intensity=opt[3])

    return result

@cython.cclass
class Coincidences:
    """Coincidence measurement

    Args:
        buffer (TangyBuffer) :
        channels (List[int]):
        delays (Optional[List[float]] = None):
    """

    _type: _tangy.BufferType
    _buffer_ptr: _Buffer_Ptr
    _measurement = cython.declare(_Coinc_Measurement)

    _n: u64n

    channels: ndarray(u8n)
    delays: ndarray(f64n)

    _channels_view: cython.uchar[:]
    _delays_view: cython.double[:]

    def __init__(self, buffer: TangyBuffer, channels: List[int],
                 delays: Optional[List[float]] = None):

        n: u64n = len(channels)
        self._n = n

        self.channels = asarray(channels, dtype=u8n)
        self.delays = zeros(n, dtype=f64n)

        if delays:
            for i in range(n):
                self.delays[i] = delays[i]

        self._channels_view = self.channels
        self._delays_view = self.delays

        channels_ptr = cython.address(self._channels_view[0])

        resolution = buffer.resolution

        if type(resolution) is float:
            self._type = _tangy.BufferType.Standard
            _res_std: _tangy.std_res = resolution
            self._measurement = _Coinc_Measurement(
                standard=_tangy.std_coincidence_measurement_new(
                    _res_std, n, channels_ptr))
            self._buffer_ptr = _Buffer_Ptr(standard=buffer._ptr.standard)

        elif type(resolution) is tuple:
            self._type = _tangy.BufferType.Clocked
            _res_clk: _tangy.clk_res
            _res_clk.coarse = resolution[0]
            _res_clk.fine = resolution[1]
            self._measurement = _Coinc_Measurement(
                clocked=_tangy.clk_coincidence_measurement_new(
                    _res_clk, n, channels_ptr))
            self._buffer_ptr = _Buffer_Ptr(clocked=buffer._ptr.clocked)

        return

    def __del__(self):
        if self._type is _tangy.BufferType.Standard:
            _tangy.std_coincidence_measurement_delete(self._measurement.standard)
        elif self._type is _tangy.BufferType.Clocked:
            _tangy.clk_coincidence_measurement_delete(self._measurement.clocked)
        return

    @ cython.ccall
    def count(self, radius: float, read_time: float) -> int:
        """ Count number of coincidences
        Args:
            raduis (float):
            read_time (float):
        Returns:
            (int): Total coincidences found
        """
        result: u64n = 0
        if self._type is _tangy.BufferType.Standard:
            result = _tangy.std_coincidences_count(self._buffer_ptr.standard,
                                                   self._n,
                                                   cython.address(self._channels_view[0]),
                                                   cython.address(self._delays_view[0]),
                                                   radius, read_time)
        elif self._type is _tangy.BufferType.Clocked:
            result = _tangy.clk_coincidences_count(self._buffer_ptr.clocked,
                                                   self._n,
                                                   cython.address(self._channels_view[0]),
                                                   cython.address(self._delays_view[0]),
                                                   radius, read_time)
        return result

    @ cython.ccall
    def collect(self, radius: float, read_time: float):
        """ Collect timetags for coincidences

        Returns:
            (Union[RecordsStandard, RecordsClocked]):
        """
        count: u64n = 0
        total: u64n = 0

        if self._type is _tangy.BufferType.Standard:
            count = _tangy.std_coincidences_records(
                self._buffer_ptr.standard,
                cython.address(self._delays_view[0]),
                radius,
                read_time,
                self._measurement.standard)

            total = self._measurement.standard.total_records
            records: ndarray(u64n) = zeros(total, dtype=u64n)
            for i in range(total):
                records[i] = self._measurement.standard.records.data[i]

            return RecordsStandard(total, self._measurement.standard.resolution,
                                   asarray(self.channels), records)

        elif self._type is _tangy.BufferType.Clocked:
            count = _tangy.clk_coincidences_records(
                self._buffer_ptr.clocked,
                cython.address(self._delays_view[0]),
                radius,
                read_time,
                self._measurement.clocked)

            total = self._measurement.clocked.total_records

            clocks: ndarray(u64n) = zeros(total, dtype=u64n)
            deltas: ndarray(u64n) = zeros(total, dtype=u64n)
            for i in range(total):
                clocks[i] = self._measurement.clocked.records.data.clock[i]
                deltas[i] = self._measurement.clocked.records.data.delta[i]

            return RecordsClocked(total,
                                  self._measurement.clocked.resolution.coarse,
                                  self._measurement.clocked.resolution.fine,
                                  asarray(self.channels), clocks, deltas)

@cython.cclass
class JointDelayHistogram:
    """Coincidence measurement

    TODO:
        testing

    Args:
        buffer (TangyBuffer) :
        channels (List[int]):
        delays (Optional[List[float]] = None):
    """

    _type: _tangy.BufferType
    _buffer_ptr: _Buffer_Ptr
    _measurement = cython.declare(_tangy.delay_histogram_measurement)
    _measurement_ptr = cython.declare(cython.pointer(_tangy.delay_histogram_measurement))
    _radius: float
    _central_bin: int

    _n: u64n

    channels: ndarray(u8n)
    delays: ndarray(f64n)

    _channels_view: cython.uchar[:]
    _delays_view: cython.double[:]

    _histogram: ndarray(u64n)
    _temporal_window: int
    _histogram_view: u64[:, ::1]
    _histogram_ptrs: cython.pointer(cython.pointer(u64))

    def __init__(self, buffer: TangyBuffer, channels: List[int], signal: int,
                 idler: int, radius: cython.double, clock: Optional[int] = 0,
                 delays: Optional[List[float]] = None):

        n: u64n = len(channels)
        self._n = n

        self.channels = asarray(channels, dtype=u8n)
        self.delays = zeros(n, dtype=f64n)

        if delays:
            for i in range(n):
                self.delays[i] = delays[i]

        self._channels_view = self.channels
        self._delays_view = self.delays

        self._radius = radius
        radius_bins = buffer.bins_from_time(radius)

        self._temporal_window = radius_bins * 2
        self._central_bin = radius_bins
        # self.histogram = zeros(self._temporal_window * self._temporal_window, dtype=uint32)
        # self._histogram_view = self.histogram

        self._histogram = zeros([self._temporal_window, self._temporal_window],
                                dtype=u64n, order='C')
        self._histogram_view = self._histogram

        channels_ptr = cython.address(self._channels_view[0])

        resolution = buffer.resolution

        if type(resolution) is float:
            self._type = _tangy.BufferType.Standard
            self._measurement = _tangy.std_dh_measurement_new(n, clock, signal, idler, channels_ptr)
            self._measurement_ptr = cython.address(self._measurement)
            self._buffer_ptr = _Buffer_Ptr(standard=buffer._ptr.standard)

        elif type(resolution) is tuple:
            self._type = _tangy.BufferType.Clocked
            self._measurement = _tangy.clk_dh_measurement_new(n, clock, signal, idler, channels_ptr)
            self._measurement_ptr = cython.address(self._measurement)
            self._buffer_ptr = _Buffer_Ptr(clocked=buffer._ptr.clocked)

        return

    def __del__(self):
        # BUG: double free? Invalid pointer either way...
        # if self._type is _tangy.BufferType.Standard:
        #     _tangy.std_dh_measurement_delete(self._measurement_ptr)
        # elif self._type is _tangy.BufferType.Clocked:
        #     _tangy.clk_dh_measurement_delete(self._measurement_ptr)
        # free(self._histogram_ptrs)
        return

    @ cython.ccall
    def histogram(self, bin_width: Optional[int] = 1,
                  centre: bool = False) -> JointHistogram:
        # TODO: add an inplace option, default to false and create new memory
        # on each call

        if bin_width < 1:
            raise ValueError("bin_width must be >= 1")

        temporal_window = self._temporal_window
        central_bin = self._central_bin
        if bin_width != 1:
            temporal_window_scaled = self._temporal_window // bin_width
            temporal_window = temporal_window_scaled
            central_bin = temporal_window // 2

            hist = zeros([temporal_window_scaled, temporal_window_scaled],
                         dtype=u64n)

            i: cython.Py_ssize_t
            i_start: cython.Py_ssize_t
            i_stop: cython.Py_ssize_t
            j: cython.Py_ssize_t
            j_start: cython.Py_ssize_t
            j_stop: cython.Py_ssize_t
            # TODO: should be able to accumulate marginals in this loop
            # PERF: will make this quicker when binning the histogram
            for i in range(temporal_window_scaled):
                i_start = i * bin_width
                i_stop = i_start + bin_width
                for j in range(temporal_window_scaled):
                    j_start = j * bin_width
                    j_stop = j_start + bin_width
                    hist[i][j] = npsum(self._histogram[i_start:i_stop, j_start:j_stop])
        else:
            hist = asarray(self._histogram.copy(), dtype=u64n)

        marginal_idler = npsum(hist, axis=0)
        marginal_signal = npsum(hist, axis=1)

        if centre:
            bins = arange(temporal_window) - central_bin

            offset_idler: int = int(npround(
                mean(bins[marginal_idler > (0.1 * marginal_idler.max())])))
            offset_signal: int = int(npround(
                mean(bins[marginal_signal > (0.1 * marginal_signal.max())])))

            offset_idler *= (-1)
            offset_signal *= (-1)

            return JointHistogram(
                roll(roll(hist, offset_idler, axis=0), offset_signal, axis=1),
                marginal_idler,
                marginal_signal)

        return JointHistogram(hist, marginal_idler, marginal_signal)

    @ cython.ccall
    def collect(self, read_time: float):
        """ Collect timetags for coincidences

        Returns:
            (Union[RecordsStandard, RecordsClocked]):
        """
        count: u64n = 0
        total: u64n = 0

        self._histogram_ptrs = cython.cast(
            cython.pointer(cython.pointer(u64)),
            malloc(self._temporal_window * cython.sizeof(u64)))

        int: cython.Py_ssize_t = 0
        for i in range(self._temporal_window):
            self._histogram_ptrs[i] = cython.address(self._histogram_view[i, 0])

        if self._type is _tangy.BufferType.Standard:
            count = _tangy.std_joint_delay_histogram(
                self._buffer_ptr.standard,
                cython.address(self._delays_view[0]),
                self._radius,
                read_time,
                self._measurement_ptr,
                cython.address(self._histogram_ptrs[0]))

        elif self._type is _tangy.BufferType.Clocked:
            count = _tangy.clk_joint_delay_histogram(
                self._buffer_ptr.clocked,
                cython.address(self._delays_view[0]),
                self._radius,
                read_time,
                self._measurement_ptr,
                cython.address(self._histogram_ptrs[0]))

        # free(self._measurement_ptr)
        return count


